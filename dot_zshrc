# HELP
# - https://unix.stackexchange.com/a/487889/612293 - .zshenv, .zprofile, .zshrc,...

# REF:
# - https://github.com/mischavandenburg/dotfiles
# - https://github.com/dreamsofautonomy/zensh
# - https://github.com/Alexis12119/dotfiles
# - https://github.com/stevearc/dotfiles
# - https://github.com/omerxx/dotfiles
# - https://github.com/rusty-electron/dotfiles
# - https://github.com/chaneyzorn/dotfiles
# - https://github.com/siduck/dotfiles
# - https://github.com/craftzdog/dotfiles-public
# - https://github.com/JoosepAlviste/dotfiles
# - https://github.com/petobens/dotfiles
# - https://github.com/asilvadesigns/config


##########################################

# UPDATE PATH
typeset -aU path # Avoid recursively lengthen $path in subshell
export path=(
  $HOME/.local/share/nvim/mason/bin
  $HOME/.scripts
  $path
)


##########################################

# If not running interactively, don't do anything
[[ $- != *i* ]] && return


##########################################

# LIST OF PLUGINS TO USE IN OH-MY-ZSH
plugins=(
  git
  gh
  sudo
  zsh-256color
  zsh-autosuggestions
  zsh-syntax-highlighting
  history-substring-search # Always below zsh-syntax-highlighting
  wakatime
  fzf
  fzf-tab
  archlinux
  docker
  docker-compose
  tmux
  dotenv
  extract
  fancy-ctrl-z
)
source $ZSH/oh-my-zsh.sh


##########################################

# UTILS

has() {
	command -v $1 >/dev/null
}

# EVALX
declare -A _EVALX_COMMANDS=( 
  [clean_flatpak]='flatpak uninstall --unused'
  [clean_pacman]='sudo pacman -Scc'
  [echo_key_press]='echo $(read -k 1)'
  [source_Hyde_completion]='source Hyde.zsh'
  [source_chezmoi_completion]='source <(chezmoi completion zsh)'
  [source_npm_completion]='source <(npm completion)'
  [source_warp_cli_completion]='source <(warp-cli generate-completions zsh)'
  [start_ssh_agent]='eval "$(ssh-agent -s)"'
)

evalx() {
  local commands=$(printf "%s\n" "${(@k)_EVALX_COMMANDS}" | fzf --multi)
  for key in "${commands[@]}"
  do
    eval "${_EVALX_COMMANDS[$key]}"
  done
}

clean_all() {
  if has pacman; then
    printf "\nCLEAN PACMAN..."
    eval "${_EVALX_COMMANDS[clean_pacman]}"
  fi
  if has flatpak; then
    printf "\nCLEAN FLATPAK..."
    eval "${_EVALX_COMMANDS[clean_flatpak]}"
  fi
}


##########################################

# KEYBINDINGS
bindkey -e
bindkey '^p' history-substring-search-up
bindkey '^n' history-substring-search-down
bindkey '^[w' kill-region # Delete all words before cursor
bindkey '^H' backward-kill-word # Source: https://www.reddit.com/r/neovim/comments/18txgth/ctrlbackspace_doesnt_work_as_intended_in_neovim


##########################################

# ZSH CONFIG
HISTDUP=erase
HISTFILE=~/.zsh_history
HISTORY_SUBSTRING_SEARCH_PREFIXED=1
HISTSIZE=5000
SAVEHIST=$HISTSIZE
setopt APPENDHISTORY
setopt GLOBDOTS # Include hidden dir tab complete
setopt HIST_FIND_NO_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS
setopt IGNOREEOF # Prevents <C-d> from quitting the shell
setopt PROMPT_SUBST # Enable scripting in the prompt
setopt SHAREHISTORY # Share history across shell
unsetopt BEEP # Prevents beeps in general


##########################################

# ZSH STYLE
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' menu no
zstyle ':completion:*:descriptions' format '[%d]'
zstyle ':completion:*:git-checkout:*' sort false
zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup
zstyle ':fzf-tab:*' switch-group '<' '>'
zstyle ':fzf-tab:complete:cd:*' popup-pad 30 0
zstyle ':fzf-tab:*' popup-min-size 120 10
zstyle ':fzf-tab:complete:__zoxide_z:*' fzf-preview 'eza -1 --color=always --icons=always $realpath'
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always --icons=always $realpath'


##########################################

# ALIAS / FUNCTION

# Apps
install_apps()
{
  local distro
  distro=$(lsb_release -i | awk '{print $NF}')

  case "$distro" in
    "Arch")
      if has yay; then
        yay -Slq | fzf --multi --preview 'yay -Si {1}' | xargs -ro yay -S
      else
        pacman -Slq | fzf --multi --preview 'pacman -Si {1}' | xargs -ro sudo pacman -S
      fi
      ;;
    "Ubuntu"|"Debian")
      apt list | fzf --multi --preview 'apt info {1}' | xargs -ro sudo apt install
      ;;
    "Fedora"|"CentOS"|"RedHat")
      dnf list --available | fzf --multi --preview 'dnf info {1}' | xargs -ro sudo dnf install
      ;;
    *)
      echo "Unsupported distribution: $distro"
      return 1
      ;;
  esac
}
alias ia='install_apps'

uninstall_apps()
{
  local distro
  distro=$(lsb_release -i | awk '{print $NF}')

  case "$distro" in
    "Arch")
      if has yay; then
        yay -Qq | fzf --multi --preview 'yay -Si {1}' | xargs -ro yay -Rs --confirm
      else
        pacman -Qq | fzf --multi --preview 'pacman -Si {1}' | xargs -ro sudo pacman -Rs --confirm
      fi
      ;;
    "Ubuntu"|"Debian")
      apt list --installed | fzf --multi --preview 'apt info {1}' | xargs -ro sudo apt uninstall
      ;;
    "Fedora"|"CentOS"|"RedHat")
      dnf list --installed | fzf --multi --preview 'dnf info {1}' | xargs -ro sudo dnf uninstall
      ;;
    *)
      echo "Unsupported distribution: $distro"
      return 1
      ;;
  esac
}
alias ua='uninstall_apps'


# Ls
if has eza; then
  EZA_OPTS=(--group-directories-first -s Name -I '.DS_Store' --icons=auto --colour=always)
  alias l="eza -lh  $EZA_OPTS" # long list
	alias ls="exa -1 $EZA_OPTS" # Normal ls
	alias ll="exa -lag $EZA_OPTS"
  alias ld="eza -lhD $EZA_OPTS" # long list dirs
  alias lt="eza --icons=auto --tree $EZA_OPTS" # list folder as tree
else
	alias ls='ls -A --color=auto'
	alias ll='ls -lAg --color=auto'
fi

# Change directory
alias ..='cd ..'
alias ...='cd ../..'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias .5='cd ../../../../..'

# Make directory
alias mkdir='mkdir -p'

# Chezmoi
cmc() {
  { [ -n "$1" ] && chezmoi git "commit -m \"$1\"" || chezmoi git "commit"; } && chezmoi git push
}
cms() { 
  chezmoi re-add
  chezmoi git "f" || { echo 'No "f" alias for git!'; cmc; }
}
alias cm='chezmoi'
alias cma='chezmoi add'

# Tmux
alias t='tmux'
tks() { 
  if [ "$#" != "0" ]; then
    tmux kill-session -t $@
  else
    tmux kill-server
  fi
}
ta() { 
  if [ "$#" != "0" ]; then
    tmux attach -t $@
  else
    tmux has-session &>/dev/null && tmux attach || tmux
  fi
}

# ChatGPT gen it for me :(
yzcd() {
  local tmp=$(mktemp)
  yazi "$@" --cwd-file="$tmp"
  local cwd=$(<"$tmp")
  if [[ -n "$cwd" && "$cwd" != "$PWD" ]]; then
    cd "$cwd"
  fi
  rm "$tmp"
}
bindkey -s '^d' 'yzcd\n'

# Others
alias rl='source ~/.zshrc'
bindkey -s '^[R' 'rl\n'
alias v='nvim'
alias lg='lazygit'
alias yz='yazi'
alias c='clear'
alias cls='clear'
alias ccccccc='clear'


##########################################

# TMUX

# if [ -n "$TMUX" ]; then
#    enable-fzf-tab
# fi


##########################################

# FZF

_fzf_open_path() {
	local input_path=$1
	if [ ! -n "$input_path" ]; then
		return 1
	fi
  declare -A cmds=(
    [bat]='bat $input_path'
    [cat]='cat $input_path'
    [cd]='[[ -f "$input_path" ]] && input_path=$(dirname "$input_path"); cd $input_path'
    [nvim]='nvim $input_path'
    [remove]='rm -rf $input_path'
    [echo]='echo $input_path'
  )
  local cmd=$(printf "%s\n" "${(@k)cmds}" | fzf --prompt 'Select command> ')
  eval "${cmds[$cmd]}" 
}

_fzf_get_path_using_fd() {
	local input_path=$(
		fd --type file |
			fzf --prompt 'Files> ' \
				--header 'CTRL-S: Switch between Files/Directories' \
				--bind 'ctrl-s:transform:[[ ! $FZF_PROMPT =~ Files ]] &&
        echo "change-prompt(Files> )+reload(fd --type file)" ||
        echo "change-prompt(Directories> )+reload(fd --type directory)"' \
				--preview '[[ $FZF_PROMPT =~ Files ]] && bat --color=always --style=plain {} || tree -C {}'
	)
	echo "$input_path"
}

_fzf_get_path_using_rg() {
	rm -f /tmp/rg-fzf-{r,f}
	local RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
	local INITIAL_QUERY="${*:-}"
	local input_path=$(
		fzf --ansi --disabled --query "$INITIAL_QUERY" \
      --bind "enter:become(echo {1})" \
			--bind "start:reload:$RG_PREFIX {q}" \
			--bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
			--bind 'ctrl-s:transform:[[ ! $FZF_PROMPT =~ ripgrep ]] &&
      echo "rebind(change)+change-prompt(1. ripgrep> )+disable-search+transform-query:echo \{q} > /tmp/rg-fzf-f; cat /tmp/rg-fzf-r" ||
      echo "unbind(change)+change-prompt(2. fzf> )+enable-search+transform-query:echo \{q} > /tmp/rg-fzf-r; cat /tmp/rg-fzf-f"' \
			--color "hl:-1:underline,hl+:-1:underline:reverse" \
			--prompt '1. ripgrep> ' \
			--delimiter : \
			--header 'CTRL-S: Switch between ripgrep/fzf' \
			--preview 'bat --color=always {1} --highlight-line {2} --style=plain' \
			--preview-window 'up,60%,border-bottom,+{2}+3/3'
	)
	echo "$input_path"
}

fdg() {
  _fzf_open_path "$(_fzf_get_path_using_fd)"
}

rgg() {
  _fzf_open_path "$(_fzf_get_path_using_rg)"
}

bindkey -s '^G' 'rgg\n'
bindkey -s '^F' 'fdg\n'


# NOTE: this is for ... inplace but nah. This is trash

# fdg() {
#   local output=$(__fzf_open_path "$(__fzf_get_path_using_fd)" 'true')
#   if [[ -n "$LBUFFER" ]]; then
#     LBUFFER+="${output}"
#   fi
#   local ret=$?
#   zle reset-prompt
#   return $ret
# }
# zle -N fdg
#
# rgg() {
#   local output=$(__fzf_open_path "$(__fzf_get_path_using_rg)" 'true')
#   if [[ -n "$LBUFFER" ]]; then
#     LBUFFER+="${output}"
#   fi
#   local ret=$?
#   zle reset-prompt
#   return $ret
# }
# zle -N rgg
#
# bindkey '^F' fdg
# bindkey '^G' rgg


##########################################

# BAT

alias -g -- -h='-h 2>&1 | bat --language=help --style=plain'
alias -g -- --help='--help 2>&1 | bat --language=help --style=plain'

alias bathelp='bat --plain --language=help'
help() {
    "$@" --help 2>&1 | bathelp
}


##########################################

# WIFI
# Source: https://gist.github.com/guyzmo/146423d0cf7d3c0a46e10eeb66883905

connect_wifi() {
	local ssid
	local conn

	nmcli device wifi rescan >/dev/null
	ssid=$(nmcli device wifi list | tail -n +2 | grep -v '^  *\B--\B' | fzf -m | sed 's/^ *\*//' | awk '{print $1}')

	if [ "x$ssid" != "x" ]; then
		# check if the SSID has already a connection setup
		conn=$(nmcli con | grep "$ssid" | awk '{print $1}' | uniq)
		if [ "x$conn" = "x$ssid" ]; then
			echo "Please wait while switching to known network $ssid…"
			# if yes, bring up that connection
			nmcli con up id "$conn"
		else
			echo "Please wait while connecting to new network $ssid…"
			# if not connect to it and ask for the password
			nmcli device wifi connect "$ssid"
		fi
	fi
}

get_current_wifi_password() {
	nmcli device wifi show-password
}

get_wifi_password() {
	local ssid
  ssid=$(nmcli --colors=no --fields=NAME --terse connection show |
    fzf --preview='nmcli -s -g 802-11-wireless-security.psk connection show {} || echo "Cannot get password!"'
      --preview-window='right,70%,border-left'
    )

	if [[ -z "$ssid" ]]; then
		echo "No SSID was selected!"
		return
	fi
	local password=$(nmcli -s -g 802-11-wireless-security.psk connection show $ssid)
	echo "SSID: $ssid"
	echo "PASSWORD: $password"
}


##########################################

# RUN SOME STUFF
fastfetch
eval "$(starship init zsh)"
eval "$(zoxide init zsh --cmd cd)"
eval "$(pyenv init -)"
